[{"name":"ActorModel","comment":"\n\n\n# The Basic Stuff\n\nThe actor model adopts the philosophy that everything is an actor. This is similar to the everything is an object philosophy used by some object-oriented programming languages.\n\nAn actor is a computational entity that, in response to a message it receives, can concurrently:\n\n  - send a finite number of messages to other actors;\n  - create a finite number of new actors;\n  - designate the behavior to be used for the next message it receives.\n\nThere is no assumed sequence to the above actions and they could be carried out in parallel.\n\nDecoupling the sender from communications sent was a fundamental advance of the actor model enabling asynchronous communication and control structures as patterns of passing messages.\n\nRecipients of messages are identified by address, sometimes called \"mailing address\". Thus an actor can only communicate with actors whose addresses it has. It can obtain those from a message it receives, or if the address is for an actor it has itself created.\n\nThe actor model is characterized by inherent concurrency of computation within and among actors, dynamic creation of actors, inclusion of actor addresses in messages, and interaction only through direct asynchronous message passing with no restriction on message arrival order.\n\n@docs Address, Inbox\n\n\n## Spawning a process (Actor)\n\nA process is just a function that takes an `Inbox msg` as argument.\n\n    myActor : Inbox msg -> IO err ()\n\nThe inbox can be used to receive messages from other processes (actors).\nAs long as you don't send this `Inbox` to someone else, only you can read\nmessages.\n\n`spawn` returns the `Address` to the same inbox so that other actors\ncan send messages to it.\n\n@docs spawn\n\n\n## Sending & Receiving Messages\n\n@docs send, recv\n\nThis is everything you need to build distributed concurrent systems.\nEveryghing else is just here to make things more convenient.\n\n\n# Convenient Stuff\n\n## Send & Receive Messages\n\n@docs recvOnly, recvIf, sendTo, call\n\n## Defer I/O\n\n@docs deferTo, defer\n\n## Address & Inbox\n\n@docs addressOf, createInbox\n\n## Finite State Machines\n\n@docs spawnStateMachine\n\n","unions":[{"name":"Address","comment":" An Address of an `Inbox` that you can send messages to.\n","args":["msg"],"cases":[]},{"name":"Inbox","comment":" An inbox where you can retrieve messages from.\n","args":["msg"],"cases":[]}],"aliases":[],"values":[{"name":"addressOf","comment":"\n\n    type Msg\n        = Say String\n\n    myProcess : Inbox Msg -> IO String ()\n    myProcess inbox =\n        let\n            helloAddress : Address String\n            helloAddress =\n                addressOf Say inbox\n        in\n        \"Hello world\"\n            |> sendTo helloAddress\n\n","type":"(val -> msg) -> ActorModel.Inbox msg -> ActorModel.Address val"},{"name":"call","comment":" Send a message to a process and wait for the reply.\n\n    type CounterMsg\n        = Increment\n        | SendValueTo (Address Int)\n\n    getCounterValue : Address CounterMsg -> IO String Int\n    getCounterValue address =\n        call SendValueTo address\n\n","type":"(ActorModel.Address value -> msg) -> ActorModel.Address msg -> Posix.IO.IO String.String value"},{"name":"createInbox","comment":" ","type":"Posix.IO.IO x (ActorModel.Inbox msg)"},{"name":"defer","comment":" ","type":"Posix.IO.IO err msg -> ActorModel.Address msg -> Posix.IO.IO err ()"},{"name":"deferTo","comment":" Perform IO asynchronusly.\n\n    type Msg\n        = GotResult String\n\n    myProcess : Inbox Msg -> IO String ()\n    myProcess inbox =\n        fetchFromSlowHttp\n            |> deferTo (addressOf GotResult inbox)\n            |> IO.andThen continueWithoutWaiting\n\n","type":"ActorModel.Address msg -> Posix.IO.IO err msg -> Posix.IO.IO err ()"},{"name":"recv","comment":" Retrieve a message from an inbox. Will block\nif the inbox is empty.\n","type":"ActorModel.Inbox msg -> Posix.IO.IO String.String msg"},{"name":"recvIf","comment":" Blocks until an accepted message can be received.\n","type":"(msg -> Basics.Bool) -> ActorModel.Inbox msg -> Posix.IO.IO String.String msg"},{"name":"recvOnly","comment":" Blocks until an accepted message can be received.\n","type":"(recv -> Maybe.Maybe msg) -> ActorModel.Inbox recv -> Posix.IO.IO String.String msg"},{"name":"send","comment":" Send a message to an Inbox identified by an address.\n","type":"msg -> ActorModel.Address msg -> Posix.IO.IO String.String ()"},{"name":"sendTo","comment":" Might block if channel buffer is full\n","type":"ActorModel.Address msg -> msg -> Posix.IO.IO err ()"},{"name":"spawn","comment":"\n\n    main =\n        spawn helloProcess\n            |> IO.andThen\n                (\\helloAddress ->\n                    IO.send SayHello helloAddress\n                )\n\n    type HelloMsg\n        = SayHello\n\n    helloProcess : Inbox HelloMsg -> IO String ()\n    helloProcess inbox =\n        IO.recv inbox\n            |> IO.andThen\n                (\\msg ->\n                    case msg of\n                        SayHello ->\n                            IO.printLn \"Hello\"\n                )\n\n","type":"(ActorModel.Inbox msg -> Posix.IO.IO err ()) -> Posix.IO.IO err (ActorModel.Address msg)"},{"name":"spawnStateMachine","comment":" Spawn a \"The-Elm-Architecture\" update function (finite state machine).\n\n    main =\n        spawnStateMachine counter 0\n\n    type Msg\n        = Increment\n        | SendValueTo (Address Int)\n\n    type alias Model =\n        Int\n\n    counter : Msg -> Model -> ( Model, IO String () )\n    counter msg model =\n        case msg of\n            Increment ->\n                ( model + 1\n                , IO.none\n                )\n\n            SendValueTo replyAddress ->\n                ( model\n                , send model replyAddress\n                )\n\n","type":"(msg -> model -> ( model, Posix.IO.IO String.String () )) -> model -> Posix.IO.IO String.String (ActorModel.Address msg)"}],"binops":[]}]