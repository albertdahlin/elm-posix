[{"name":"Posix.IO","comment":"\n\n\n# Create IO\n\nThe `IO err ok` type is very similar in concept to `Task err ok`. The first parameter is the error\nvalue, the second value is the \"return\" value of an IO-operation.\n\nA program must have the type `IO String ()`. The error parameter must have type `String`.\nThis allows the runtime to print error message to std err in case of a problem.\n\n@docs IO, return, fail, none\n\n\n# Basic IO\n\n@docs print, printLn, sleep, exit\n\n\n# Transforming IO\n\n@docs map, andMap, andThen, and, combine\n\n\n# Handle Errors\n\n@docs mapError, recover\n\n\n# Tasks\n\n@docs performTask, attemptTask\n\n\n# Javascript Interop\n\n@docs callJs\n\n\n# Program\n\n@docs makeProgram, Process, PortIn, PortOut\n\n","unions":[],"aliases":[{"name":"IO","comment":" ","args":["err","ok"],"type":"Internal.ContWithResult.Cont Internal.Process.Proc err ok"},{"name":"PortIn","comment":" ","args":["msg"],"type":"Internal.Process.PortIn msg"},{"name":"PortOut","comment":" ","args":["msg"],"type":"Internal.Process.PortOut msg"},{"name":"Process","comment":" ","args":[],"type":"{ argv : List.List String.String, pid : Basics.Int, env : Dict.Dict String.String String.String }"}],"values":[{"name":"and","comment":" Instead of:\n\n    sleep 100\n        |> andThen (\\_ -> printLn \"Hello\")\n\n`and` allows you to do:\n\n    sleep 100\n        |> and (printLn \"Hello\")\n\n","type":"Posix.IO.IO x b -> Posix.IO.IO x a -> Posix.IO.IO x b"},{"name":"andMap","comment":" Applicative\n\n    map2 : (a -> b -> c) -> IO x a -> IO x b -> IO x c\n    map2 fn a b =\n        IO.return fn\n            |> IO.andMap a\n            |> IO.andMap b\n\n","type":"Posix.IO.IO x a -> Posix.IO.IO x (a -> b) -> Posix.IO.IO x b"},{"name":"andThen","comment":" ","type":"(a -> Posix.IO.IO x b) -> Posix.IO.IO x a -> Posix.IO.IO x b"},{"name":"attemptTask","comment":" Attempt a Task that can fail.\n\nFor example you can fetch data using the [elm/http](https://package.elm-lang.org/packages/elm/http/latest/Http) package.\n\n    import Http\n\n    fetch : IO String String\n    fetch =\n        Http.riskyTask\n            { method = \"GET\"\n            , headers = []\n            , url = \"http://example.com\"\n            , body = Http.emptyBody\n            , resolver = Http.stringResolver stringBody\n            , timeout = Just 10\n            }\n            |> attemptTask\n\n\n    stringBody : Http.Response String -> Result String String\n    stringBody response =\n        case response of\n            Http.GoodStatus_ metaData body ->\n                Ok body\n\n            _ ->\n                Err \"Problem\"\n\n","type":"Task.Task err ok -> Posix.IO.IO err ok"},{"name":"callJs","comment":" Call a synchronous function in Javascript land.\n\nThis works by sending out a message through a port. The Javascript implementation\nwill then send the return value back through another port.\n\n```sh\ncallJs <fn> <args> <result decoder>\n```\n\n\n### Example\n\njs/my-functions.js\n\n```javascript\nmodule.exports = {\n    addOne: function(num) {\n        this.send(num + 1);\n    },\n}\n```\n\nsrc/MyModule.elm\n\n    addOne : Int -> IO x Int\n    addOne n =\n        IO.callJs\n            \"addOne\"\n            [ Encode.int n\n            ]\n            Decode.int\n\nRun like this:\n\n```sh\nelm.cli run --ext js/my-functions.js src/MyModule.elm\n```\n\n","type":"String.String -> List.List Json.Encode.Value -> Json.Decode.Decoder a -> Posix.IO.IO x a"},{"name":"combine","comment":" ","type":"List.List (Posix.IO.IO err ok) -> Posix.IO.IO err (List.List ok)"},{"name":"exit","comment":" Exit to shell with a status code\n","type":"Basics.Int -> Posix.IO.IO x ()"},{"name":"fail","comment":" ","type":"err -> Posix.IO.IO err a"},{"name":"makeProgram","comment":" Used by `elm-cli` to wrap your program.\n\nCreate your own program by defining `program` in your module.\n\n    program : Process -> IO String ()\n    program process =\n        printLn \"Hello, world!\"\n\n","type":"(Posix.IO.Process -> Posix.IO.IO String.String ()) -> Internal.Process.PosixProgram"},{"name":"map","comment":" ","type":"(a -> b) -> Posix.IO.IO x a -> Posix.IO.IO x b"},{"name":"mapError","comment":" ","type":"(x -> y) -> Posix.IO.IO x a -> Posix.IO.IO y a"},{"name":"none","comment":" ","type":"Posix.IO.IO x ()"},{"name":"performTask","comment":" Perform a task\n\n    getTime : IO x Time.Posix\n    getTime =\n        performTask Time.now\n\n","type":"Task.Task Basics.Never a -> Posix.IO.IO x a"},{"name":"print","comment":" ","type":"String.String -> Posix.IO.IO x ()"},{"name":"printLn","comment":" ","type":"String.String -> Posix.IO.IO x ()"},{"name":"recover","comment":" ","type":"(err -> Posix.IO.IO x ok) -> Posix.IO.IO err ok -> Posix.IO.IO x ok"},{"name":"return","comment":" ","type":"a -> Posix.IO.IO err a"},{"name":"sleep","comment":" Sleep process execution in milliseconds.\n","type":"Basics.Float -> Posix.IO.IO x ()"}],"binops":[]},{"name":"Posix.IO.Directory","comment":"\n\n\n# Directory Entry\n\n@docs Path, Entry, resolve, absolutePath, fileType, FileType\n\n\n# File Stat\n\n@docs stat, Stat\n\n\n# Directory Contents\n\n@docs Pattern, list\n\n\n# Directory Operations\n\n@docs delete, copy, rename, symlink, mkdir\n\n\n# Permissions\n\n@docs setPermission, addPermission, removePermission\n\n","unions":[{"name":"Entry","comment":" ","args":[],"cases":[]},{"name":"FileType","comment":" ","args":[],"cases":[["BlockDevice",[]],["CharacterDevice",[]],["Dir",[]],["FIFO",[]],["File",[]],["Socket",[]],["SymbolicLink",[]]]}],"aliases":[{"name":"Path","comment":" ","args":[],"type":"String.String"},{"name":"Pattern","comment":" File name, dir, glob pattern etc.\n","args":[],"type":"String.String"},{"name":"Stat","comment":" ","args":[],"type":"{ type_ : Posix.IO.Directory.FileType, mode : Posix.IO.File.Permission.Permission, owner : Basics.Int, group : Basics.Int, size : Basics.Int, lastAccessed : Time.Posix, lastModified : Time.Posix, lastStatusChanged : Time.Posix, createdAt : Time.Posix, absolutePath : Posix.IO.Directory.Path }"}],"values":[{"name":"absolutePath","comment":" ","type":"Posix.IO.Directory.Entry -> Posix.IO.Directory.Path"},{"name":"addPermission","comment":" ","type":"Posix.IO.File.Permission.Permission -> Posix.IO.Directory.Pattern -> Posix.IO.IO String.String ()"},{"name":"copy","comment":" ","type":"List.List Posix.IO.Directory.Pattern -> Posix.IO.Directory.Path -> Posix.IO.IO String.String ()"},{"name":"delete","comment":" ","type":"List.List Posix.IO.Directory.Pattern -> Posix.IO.IO String.String ()"},{"name":"fileType","comment":" ","type":"Posix.IO.Directory.Entry -> Posix.IO.Directory.FileType"},{"name":"list","comment":" ","type":"Posix.IO.Directory.Pattern -> Posix.IO.IO String.String (List.List Posix.IO.Directory.Entry)"},{"name":"mkdir","comment":" ","type":"Posix.IO.Directory.Path -> Posix.IO.IO String.String ()"},{"name":"removePermission","comment":" ","type":"Posix.IO.File.Permission.Permission -> Posix.IO.Directory.Pattern -> Posix.IO.IO String.String ()"},{"name":"rename","comment":" ","type":"Posix.IO.Directory.Pattern -> Posix.IO.Directory.Path -> Posix.IO.IO String.String ()"},{"name":"resolve","comment":" ","type":"Posix.IO.Directory.Path -> Posix.IO.IO String.String Posix.IO.Directory.Entry"},{"name":"setPermission","comment":" Set the permission\n","type":"Posix.IO.File.Permission.Permission -> Posix.IO.Directory.Pattern -> Posix.IO.IO String.String ()"},{"name":"stat","comment":" ","type":"Posix.IO.Directory.Entry -> Posix.IO.Directory.Stat"},{"name":"symlink","comment":" ","type":"Posix.IO.Directory.Path -> Posix.IO.Directory.Path -> Posix.IO.IO String.String ()"}],"binops":[]},{"name":"Posix.IO.File","comment":" This module provides a simple API for reading and writing whole\nfiles at once.\n\nFile IO can fail for many reasons. If there is an IO problem you basically have two\noptions:\n\n  - Recover by handing the error case in your code.\n  - Exit the program and display an error message.\n\nTo make both these approaches ergonomic each function comes in two flavours. One fails\nwith a typed error, the other fails with an error message.\n\n@docs Filename\n\n\n# Read File\n\n@docs read, read_, ReadError\n\n\n# Write File\n\n@docs write, write_, WriteError\n\n\n## How should a file be written?\n\n@docs WriteMode, WhenExists\n\n\n# Stream API\n\n@docs File, Readable, Writable\n\n\n## Open a File\n\n@docs openRead, openWrite, openReadWrite\n\n\n## Read / Write to a Stream\n\n@docs readStream, ReadResult, writeStream\n\n","unions":[{"name":"File","comment":" An open file descriptor.\n","args":["a"],"cases":[]},{"name":"ReadError","comment":" ","args":[],"cases":[["ReadFileNotFound",[]],["ReadNoPermission",[]],["ReadNotReadable",[]]]},{"name":"ReadResult","comment":" The result of reading a file stream.\n","args":[],"cases":[["EndOfFile",[]],["ReadBytes",["Basics.Int","String.String"]]]},{"name":"Readable","comment":" Phantom type indicating that a file is readable.\n","args":[],"cases":[]},{"name":"WhenExists","comment":" What should we do when a file exists?\n\n  - `Truncate` - Truncates the file and places the file pointer at the beginning.\n    This will cause the file to be overwritten.\n  - `Append` - Place the file pointer at the end of the file.\n\n","args":[],"cases":[["Truncate",[]],["Append",[]]]},{"name":"Writable","comment":" Phantom type indicating that a file is writable.\n","args":[],"cases":[]},{"name":"WriteError","comment":" ","args":[],"cases":[["WriteFileNotFound",[]],["WriteNoPermission",[]],["WriteNotExclusive",[]],["WriteNotWritable",[]]]},{"name":"WriteMode","comment":" How to handle writes?\n\n  - `CreateIfNotExists` - Create the file if it does not exist.\n  - `FailIfExists` - Open as exclusive write.\n    If the file already exists the operation will fail.\n    This is useful when you want to avoid overwriting a file by accident.\n\n","args":[],"cases":[["CreateIfNotExists",["Posix.IO.File.WhenExists","Posix.IO.File.Permission.Mask"]],["FailIfExists",["Posix.IO.File.Permission.Mask"]]]}],"aliases":[{"name":"Filename","comment":" ","args":[],"type":"String.String"}],"values":[{"name":"openRead","comment":" Open file for reading. Will fail if the file does not exist.\n","type":"Posix.IO.File.Filename -> Posix.IO.IO String.String (Posix.IO.File.File Posix.IO.File.Readable)"},{"name":"openReadWrite","comment":" Open a file for reading and writing.\n","type":"Posix.IO.File.WriteMode -> Posix.IO.File.Filename -> Posix.IO.IO String.String (Posix.IO.File.File both)"},{"name":"openWrite","comment":" Open a file for writing.\n\n    openLogFile : IO String (File Writable)\n    openLogFile =\n        openWrite\n            (CreateIfNotExists Append Permission.readWrite)\n            \"my.log\"\n\n","type":"Posix.IO.File.WriteMode -> Posix.IO.File.Filename -> Posix.IO.IO String.String (Posix.IO.File.File Posix.IO.File.Writable)"},{"name":"read","comment":" ","type":"Posix.IO.File.Filename -> Posix.IO.IO String.String String.String"},{"name":"readStream","comment":" Read _length_ bytes from a file stream. Will advance\nthe file pointer on a successful read\n","type":"{ length : Basics.Int } -> Posix.IO.File.File Posix.IO.File.Readable -> Posix.IO.IO String.String Posix.IO.File.ReadResult"},{"name":"read_","comment":" ","type":"Posix.IO.File.Filename -> Posix.IO.IO Posix.IO.File.ReadError String.String"},{"name":"write","comment":" ","type":"Posix.IO.File.WriteMode -> Posix.IO.File.Filename -> String.String -> Posix.IO.IO String.String ()"},{"name":"writeStream","comment":" Write string to a file stream. Will advance the file pointer\non a successful write.\n","type":"Posix.IO.File.File Posix.IO.File.Writable -> String.String -> Posix.IO.IO String.String ()"},{"name":"write_","comment":" ","type":"Posix.IO.File.WriteMode -> Posix.IO.File.Filename -> String.String -> Posix.IO.IO Posix.IO.File.WriteError ()"}],"binops":[]},{"name":"Posix.IO.File.Permission","comment":"\n\n# Permission Record\n@docs Permission, readWrite, true, false\n\n\n# Permission bitmask\n\n@docs Mask, toMask, fromMask, fromOctal\n\n","unions":[{"name":"Mask","comment":" The permission bitmask is wrapped to avoid confusion with a\nnormal Int\n","args":[],"cases":[["Mask",["Basics.Int"]]]}],"aliases":[{"name":"Permission","comment":" ","args":[],"type":"{ ownerRead : Basics.Bool, ownerWrite : Basics.Bool, ownerExecute : Basics.Bool, groupRead : Basics.Bool, groupWrite : Basics.Bool, groupExecute : Basics.Bool, allRead : Basics.Bool, allWrite : Basics.Bool, allExecute : Basics.Bool }"}],"values":[{"name":"false","comment":" All permission set to `False`\n\n    perm600 =\n        { false\n            | ownerRead = True\n            , ownerWrite = True\n        }\n\n","type":"Posix.IO.File.Permission.Permission"},{"name":"fromMask","comment":" Create a record from a bitmask.\n","type":"Posix.IO.File.Permission.Mask -> Posix.IO.File.Permission.Permission"},{"name":"fromOctal","comment":" Construct a bitmask from an \"octal\" number. This is useful since\nElm does not support octal literal notation.\n\n    fromOctal 775\n\n    fromOctal 664\n\n","type":"Basics.Int -> Posix.IO.File.Permission.Mask"},{"name":"readWrite","comment":" Read and write for everyone. (0o666)\n","type":"Posix.IO.File.Permission.Permission"},{"name":"toMask","comment":" Create a bitmask from a record.\n","type":"Posix.IO.File.Permission.Permission -> Posix.IO.File.Permission.Mask"},{"name":"true","comment":" All permission set to `True`\n\n    perm775 =\n        { true\n            | allWrite = False\n        }\n\n","type":"Posix.IO.File.Permission.Permission"}],"binops":[]},{"name":"Posix.IO.Process","comment":"\n\n\n# Execute shell commands\n\n@docs Exit, exec, execFile, failOnError\n\n\n# Spawn child processes\n\n@docs Pid, spawn, wait, kill, send, receive, Message\n\n","unions":[{"name":"Message","comment":" ","args":[],"cases":[["Exited",["Posix.IO.Process.Exit"]],["Message",["String.String"]]]},{"name":"Pid","comment":" ","args":[],"cases":[]}],"aliases":[{"name":"Exit","comment":" Sub-Process exit data.\n","args":[],"type":"{ status : Basics.Int, stdOut : String.String, stdErr : String.String }"}],"values":[{"name":"exec","comment":" Execute a shell command.\n\n    exec \"ls -l\"\n\n","type":"String.String -> Posix.IO.IO String.String Posix.IO.Process.Exit"},{"name":"execFile","comment":" Execute file with args\n\n    execFile \"path/to/file\" [ \"arg1\", \"arg2\" ]\n\n","type":"String.String -> List.List String.String -> Posix.IO.IO String.String Posix.IO.Process.Exit"},{"name":"failOnError","comment":" Make program fail if the status code is not zero.\nAlso unpacks stdOut and stdErr as `IO <stdErr> <stdOut>`.\n","type":"Posix.IO.IO String.String Posix.IO.Process.Exit -> Posix.IO.IO String.String String.String"},{"name":"kill","comment":" Kill process.\n","type":"Posix.IO.Process.Pid -> Posix.IO.IO String.String Posix.IO.Process.Exit"},{"name":"receive","comment":" Recevie a message from a child process. Will block\nuntil some data is available or the timeout occurs.\n\n    receive <timeout> <pid>\n\n","type":"Basics.Float -> Posix.IO.Process.Pid -> Posix.IO.IO String.String Posix.IO.Process.Message"},{"name":"send","comment":" Send a message to standard in (stdin) of a child process\n","type":"Posix.IO.Process.Pid -> String.String -> Posix.IO.IO String.String ()"},{"name":"spawn","comment":" Spawn a child process\n","type":"String.String -> List.List String.String -> Posix.IO.IO String.String Posix.IO.Process.Pid"},{"name":"wait","comment":" Wait for child process to exit.\n","type":"Posix.IO.Process.Pid -> Posix.IO.IO String.String Posix.IO.Process.Exit"}],"binops":[]},{"name":"Posix.IO.Random","comment":" This module is a workaround for the `Random` module not supporting creating Tasks.\n\nUses NodeJs [crypto.randomBytes()](https://nodejs.org/dist/latest-v14.x/docs/api/crypto.html#crypto_crypto_randombytes_size_callback) to generate a 32bit seed.\n\n@docs seed, generate\n\n","unions":[],"aliases":[],"values":[{"name":"generate","comment":" Generate a random value using a Generator.\n\n    roll : IO x Int\n    roll =\n        generate (Random.int 1 6)\n\n","type":"Random.Generator a -> Posix.IO.IO x a"},{"name":"seed","comment":" Generate a seed than can be used with `Random.step` from elm/random.\n\n    roll : IO x Int\n    roll =\n        seed\n            |> IO.map\n                (Random.step (Random.int 1 6)\n                    |> Tuple.first\n                )\n\n","type":"Posix.IO.IO x Random.Seed"}],"binops":[]}]